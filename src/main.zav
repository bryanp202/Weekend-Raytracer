pub mod std;
pub mod vec3;
pub mod ray;
pub mod hittable;
pub mod interval;
pub mod camera;
pub mod material;

use std::str::String;
use std::image::Color;
use std::image::Image;
use std::collections::list::List;
use std::rand::Rng;

use ray::Ray;
use vec3::Vec3;
use hittable::Hittable;
use hittable::HitRecord;
use hittable::Sphere;
use hittable::HittableList;
use interval::Interval;
use camera::Camera;
use material::Material;
use material::Lambertian;
use material::Metal;
use material::Dieletric;

pub const PI: f64 = 3.1415926535897932385;
pub const INFINITY: f64 = 1.7976931348623157e+308 + 1.7976931348623157e+308;
pub const INTERVAL_EMPTY: Interval = Interval::new(INFINITY, -INFINITY);
pub const INTERVAL_UNIVERSE: Interval = Interval::new(-INFINITY, INFINITY);
pub const PIXEL_INTENSITY: Interval = Interval::new(0.0, 0.999);
pub fn degrees_to_radians(degrees: f64) f64 {
    return degrees * PI / 180.0;
}

const IMAGE_PATH: *const u8 = "test.bmp";
const WORKER_THREADS: i64 = 12;
const IMAGE_WIDTH: i64 = 400;
const ASPECT_RATIO: f64 = 16.0 / 9.0;
const SAMPLES_PER_PIXEL: i64 = 2;
const MAX_DEPTH: i64 = 500;
const V_FOV: f64 = 20.0;

const LOOK_FROM: Vec3 = Vec3::new(13.0, 2.0, 3.0);
const LOOK_AT: Vec3 = Vec3::new(0.0, 0.0, 0.0);
const V_UP: Vec3 = Vec3::new(0.0, 1.0, 0.0);
const DEFOCUS_ANGLE: f64 = 0.4;
const FOCUS_DIST: f64 = 10.0;

fn main(argc: i64, argv: **const u8) i64 {
    // const malloc_start = @malloc(0);
    // defer {
    //     const malloc_end = @malloc(0);
    //     @printf("Heap leak size: %d\n", malloc_end as i64 - malloc_start as i64 - 32);
    //     @free(malloc_start);
    //     @free(malloc_end);
    // }
    const start = @nanoTimestamp();
    defer @printf("Time to run: %f secs\n", (@nanoTimestamp() - start) / 1_000_000_000.0);

    const camera = Camera::new(
        IMAGE_WIDTH,
        ASPECT_RATIO,
        SAMPLES_PER_PIXEL,
        MAX_DEPTH,
        V_FOV,
        LOOK_FROM,
        LOOK_AT,
        V_UP,
        DEFOCUS_ANGLE,
        FOCUS_DIST
    );

    var rng = Rng::new(@nanoTimestamp(), @nanoTimestamp());
    var materials = List::<Material>::with_capacity(500 as u64);
    defer {
        for (0..materials.len, materials.items) |_, mat| {
            mat.free();
        }
        materials.free();
    }
    var world_builder = HittableList::with_capacity(500 as u64);

    materials.push(Lambertian::new(Vec3::new(0.5, 0.5, 0.5)).material());
    world_builder.add(Sphere::new(Vec3::new(0.0, -1000.0, 0.0), 1000.0, &materials.items[0]).hittable());

    for (-11..11) |a| {
        for (-11..11) |b| {
            const choose_mat = rng.gen_f64();
            const center = Vec3::new(a + 0.9*rng.gen_f64(), 0.4, b + 0.9*rng.gen_f64());
            var sphere_material: Material = undefined;

            if ((center.sub(&Vec3::new(4.0, 0.2, 0.0))).len() > 0.9) {
                if (choose_mat < 0.8) {
                    const albedo = Vec3::random(&rng).mul(&Vec3::random(&rng));
                    sphere_material = Lambertian::new(albedo).material();
                } else if (choose_mat < 0.95) {
                    const albedo = Vec3::random(&rng);
                    const fuzz = rng.range_f64(0.0, 0.5);
                    sphere_material = Metal::new(albedo, fuzz).material();
                } else {
                    sphere_material = Dieletric::new(1.5).material();
                }
                materials.push(sphere_material);
                world_builder.add(Sphere::new(center, 0.2, &materials.items[materials.len - 1]).hittable());
            }
        }
    }

    materials.push(Dieletric::new(1.5).material());
    world_builder.add(Sphere::new(Vec3::new(0.0, 1.0, 0.0), 1.0, &materials.items[materials.len - 1]).hittable());

    materials.push(Lambertian::new(Vec3::new(0.4, 0.2, 0.1)).material());
    world_builder.add(Sphere::new(Vec3::new(-4.0, 1.0, 0.0), 1.0, &materials.items[materials.len - 1]).hittable());

    materials.push(Metal::new(Vec3::new(0.7, 0.6, 0.5), 0.0).material());
    world_builder.add(Sphere::new(Vec3::new(4.0, 1.0, 0.0), 1.0, &materials.items[materials.len - 1]).hittable());

    const world = world_builder.hittable();
    defer world.free();

    const export_result = camera.render(&world, IMAGE_PATH, WORKER_THREADS);

    if (export_result.is_err()) {
        @printf("[Err: On .BMP file export to file at: '%s'] %d\n", IMAGE_PATH, export_result.unwrap_err());
        return 1;
    }

    const bytes = export_result.unwrap_ok();
    @printf("Exported %d bytes to file at: '%s'\n", bytes, IMAGE_PATH);
    return 0;
}