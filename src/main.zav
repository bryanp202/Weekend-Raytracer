pub mod std;
pub mod vec3;
pub mod ray;
pub mod hittable;
pub mod interval;
pub mod camera;
pub mod material;

use std::str::String;
use std::image::Color;
use std::image::Image;
use std::collections::list::List;

use ray::Ray;
use vec3::Vec3;
use hittable::Hittable;
use hittable::HitRecord;
use interval::Interval;
use camera::Camera;
use material::Material;
use material::Lambertian;
use material::Metal;

pub const PI: f64 = 3.1415926535897932385;
pub const INFINITY: f64 = 1.7976931348623157e+308 + 1.7976931348623157e+308;
pub const INTERVAL_EMPTY: Interval = Interval::new(INFINITY, -INFINITY);
pub const INTERVAL_UNIVERSE: Interval = Interval::new(-INFINITY, INFINITY);
pub const PIXEL_INTENSITY: Interval = Interval::new(0.0, 0.999);
pub fn degrees_to_radians(degrees: f64) f64 {
    return degrees * PI / 180.0;
}

const IMAGE_PATH: *const u8 = "test.bmp";
const IMAGE_WIDTH: i64 = 400;
const ASPECT_RATIO: f64 = 16.0 / 9.0;
const FOCAL_LENGTH: f64 = 1.0;
const VIEWPORT_HEIGHT: f64 = 2.0;
const SAMPLES_PER_PIXEL: i64 = 10;
const WORKER_THREADS: i64 = 12;
const MAX_DEPTH: i64 = 50;

fn main(argc: i64, argv: **const u8) i64 {
    const malloc_start = @malloc(0);
    defer {
        const malloc_end = @malloc(0);
        @printf("Heap leak size: %d\n", malloc_end as i64 - malloc_start as i64 - 32);
        @free(malloc_start);
        @free(malloc_end);
    }
    const start = @nanoTimestamp();
    defer @printf("Time to run: %f secs\n", (@nanoTimestamp() - start) / 1_000_000_000.0);

    const camera = Camera::new(
        IMAGE_WIDTH,
        ASPECT_RATIO,
        VIEWPORT_HEIGHT,
        FOCAL_LENGTH,
        SAMPLES_PER_PIXEL,
        MAX_DEPTH
    );

    var materials = List::<Material>::new();
    defer {
        for (0..materials.len, materials.items) |_, mat| {
            mat.free();
        }
        materials.free();
    }
    materials.push(Lambertian::new(Vec3::new(0.8, 0.8, 0.0)).material());
    materials.push(Lambertian::new(Vec3::new(0.1, 0.2, 0.5)).material());
    materials.push(Metal::new(Vec3::new(0.8, 0.8, 0.8)).material());
    materials.push(Metal::new(Vec3::new(0.8, 0.6, 0.2)).material());

    var world = hittable::HittableList::new()
        .add(hittable::Sphere::new(Vec3::new(0.0, -100.5, -1.0), 100.0, &materials.items[0]).hittable())
        .add(hittable::Sphere::new(Vec3::new(0.0, 0.0, -1.2), 0.5, &materials.items[1]).hittable())
        .add(hittable::Sphere::new(Vec3::new(-1.0, 0.0, -1.0), 0.5, &materials.items[2]).hittable())
        .add(hittable::Sphere::new(Vec3::new(1.0, 0.0, -1.0), 0.5, &materials.items[3]).hittable())
        .hittable();
    defer world.free();

    const export_result = camera.render(&world, IMAGE_PATH, WORKER_THREADS);

    if (export_result.is_err()) {
        @printf("[Err: On .BMP file export to file at: '%s'] %d\n", IMAGE_PATH, export_result.unwrap_err());
        return 1;
    }

    const bytes = export_result.unwrap_ok();
    @printf("Exported %d bytes to file at: '%s'\n", bytes, IMAGE_PATH);
    return 0;
}