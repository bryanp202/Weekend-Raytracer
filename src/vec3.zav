use ::std::rand::Rng;

pub struct Vec3 {
    x: f64;
    y: f64;
    z: f64;

    pub fn new(x: f64, y: f64, z: f64) Vec3 {
        var vec: Vec3 = undefined;
        vec.x = x;
        vec.y = y;
        vec.z = z;
        return vec;
    }

    pub fn random(rng: *Rng) Vec3 {
        var vec: Vec3 = undefined;
        vec.x = rng.gen_f64();
        vec.y = rng.gen_f64();
        vec.z = rng.gen_f64();
        return vec;
    }
    pub fn random_range(rng: *Rng, min: f64, max: f64) Vec3 {
        var vec: Vec3 = undefined;
        vec.x = rng.range_f64(min, max);
        vec.y = rng.range_f64(min, max);
        vec.z = rng.range_f64(min, max);
        return vec;
    }
    pub fn random_unit_vector(rng: *Rng) Vec3 {
        while (true) {
            const p = Vec3::random_range(rng, -1.0, 1.0);
            const lensq = p.len_squared();
            if (1e-160 < lensq and lensq <= 1.0) {
                return p.divs(@sqrtf64(lensq));
            }
        }
    }
    pub fn random_on_hemisphere(rng: *Rng, normal: *const Vec3) Vec3 {
        const on_unit_sphere = Vec3::random_unit_vector(rng);
        if (on_unit_sphere.dot(normal) > 0.0)
            return on_unit_sphere;
        else
            return on_unit_sphere.neg();
    }
    pub fn random_in_unit_disk(rng: *Rng) Vec3 {
        while (true) {
            const p = Vec3::new(rng.range_f64(-1.0, 1.0), rng.range_f64(-1.0, 1.0), 0.0);
            if (p.x*p.x + p.y*p.y < 1.0) {
                return p;
            }
        }
    }

    pub fn display(self: *const Vec3) void {
        @printf("(%f, %f, %f)\n", self.x, self.y, self.z);
    }

    /* PROPERTIES */
    pub fn len(self: *const Vec3) f64 {
        return @sqrtf64(self.x * self.x + self.y * self.y + self.z * self.z);
    }
    pub fn len_squared(self: *const Vec3) f64 {
        return self.x * self.x + self.y * self.y + self.z * self.z;
    }
    pub fn near_zero(self: *const Vec3) bool {
        return (self.x <= 1e-8 and self.x >= -1e-8)
            and (self.y <= 1e-8 and self.y >= -1e-8)
            and (self.z <= 1e-8 and self.z >= -1e-8);
    }

    /* ARITHMETIC */
    pub fn neg(self: *const Vec3) Vec3 {
        return Vec3::new(-self.x, -self.y, -self.z);
    }
    pub fn add(self: *const Vec3, other: *const Vec3) Vec3 {
        return Vec3::new(self.x + other.x, self.y + other.y, self.z + other.z);
    }
    pub fn sub(self: *const Vec3, other: *const Vec3) Vec3 {
        return Vec3::new(self.x - other.x, self.y - other.y, self.z - other.z);
    }
    pub fn mul(self: *const Vec3, other: *const Vec3) Vec3 {
        return Vec3::new(self.x * other.x, self.y * other.y, self.z * other.z);
    }
    // Scalar ops
    pub fn muls(self: *const Vec3, t: f64) Vec3 {
        return Vec3::new(self.x * t, self.y * t, self.z * t);
    }
    pub fn divs(self: *const Vec3, t: f64) Vec3 {
        const t_inv = 1.0 / t;
        return Vec3::new(self.x * t_inv, self.y * t_inv, self.z * t_inv);
    }

    // Special ops
    pub fn dot(self: *const Vec3, other: *const Vec3) f64 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
    pub fn cross(self: *const Vec3, other: *const Vec3) Vec3 {
        return Vec3::new(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        );
    }
    pub fn unit_vector(self: *const Vec3) Vec3 {
        return self.divs(self.len());
    }
    pub fn reflect(self: *const Vec3, other: *const Vec3) Vec3 {
        return self.sub(&other.muls(2.0 * self.dot(other)));
    }
    pub fn refract(self: *const Vec3, other: *const Vec3, etai_over_etat: f64) Vec3 {
        const dot = -self.dot(other);
        const cos_theta = dot < 1.0 ? dot : 1.0;
        const r_out_perp = self.add(&other.muls(cos_theta)).muls(etai_over_etat);
        const len_sqrd = 1.0 - r_out_perp.len_squared();
        const r_out_parallel = other.muls(-@sqrtf64(len_sqrd >= 0.0 ? len_sqrd : -len_sqrd));
        return r_out_perp.add(&r_out_parallel);
    }
}