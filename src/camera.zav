use ::std::image::Image;
use ::std::image::Color;
use ::std::math;
use ::std::result::Result;
use ::std::io::IOError;
use ::std::collections::list::List;
use ::std::rand::Rng;

use ::vec3::Vec3;
use ::ray::Ray;
use ::hittable::Hittable;
use ::hittable::HitRecord;
use ::interval::Interval;

pub struct Camera {
    aspect_ratio: f64;
    image_width: i64;
    image_height: i64;
    center: Vec3;
    pixel00_loc: Vec3;
    pixel_delta_u: Vec3;
    pixel_delta_v: Vec3;
    samples_per_pixel: i64;
    pixel_samples_scale: f64;
    max_depth: i64;

    pub fn new(
        image_width: i64,
        aspect_ratio: f64,
        viewport_height: f64,
        focal_length: f64,
        samples_per_pixel: i64,
        max_depth: i64
    ) Camera {
        var self: Camera = undefined;
        self.aspect_ratio = aspect_ratio;
        self.image_width = image_width;
        self.image_height = math::max_i64(1, (image_width / aspect_ratio) as i64);

        const viewport_height = viewport_height;
        const viewport_width = viewport_height * (image_width as f64 / self.image_height as f64);
        self.center = Vec3::new(0.0, 0.0, 0.0);

        // Calculate the vectors across the horizontal and down the vertical viewport edges
        const viewport_u = Vec3::new(viewport_width, 0.0, 0.0);
        const viewport_v = Vec3::new(0.0, -viewport_height, 0.0);

        // Calculate the horizontal and vertical delta vectors from pixel to pixel
        self.pixel_delta_u = viewport_u.divs(image_width);
        self.pixel_delta_v = viewport_v.divs(self.image_height);

        // Calculate the position of the upper left pixel
        const viewport_upper_left = self.center
            .sub(&Vec3::new(0.0, 0.0, focal_length))
            .sub(&viewport_u.divs(2.0))
            .sub(&viewport_v.divs(2.0));
        self.pixel00_loc = viewport_upper_left
            .add(&self.pixel_delta_u.add(&self.pixel_delta_v).muls(0.5));

        self.samples_per_pixel = samples_per_pixel;
        self.pixel_samples_scale = 1.0 / samples_per_pixel;
        self.max_depth = max_depth;

        return self;
    }

    pub fn render(
        self: *const Camera,
        world: *const Hittable,
        filename: *const u8,
        thread_count: i64
    ) Result<i64, IOError> {
        const img = Image::new(self.image_width as u32, self.image_height as u32);
        defer img.free();

        var threads = List::<i64>::new();
        defer threads.free();
        var args = List::<*void>::new();
        defer args.free();

        const interval = thread_count < 2 ? 0 : self.image_height / thread_count;
        var thread_start = 0;
        for (1..thread_count) |i| {
            var temp: RenderThreadArgs = undefined;
            temp.camera = self;
            temp.world = world;
            temp.img = &img;
            temp.min = thread_start;
            temp.max = thread_start + interval;
            thread_start = temp.max;
            const arg = @malloc(@sizeof(temp)) as *RenderThreadArgs;
            arg.* = temp;
          
            const handle = @spawn_thread(Camera::render_worker, arg as *void);
            threads.push(handle);
            args.push(arg as *void);
        }
    
        var rng = Rng::new(@nanoTimestamp(), @nanoTimestamp());
        for (thread_start..self.image_height) |j| {
            @printf("\rScanlines remaining: %d ", self.image_height - j);
            for (0..self.image_width) |i| {
                self.draw_pixel(&img, world, i, j, &rng);
            }
        }
        @printf("\rDone                  \n");

        for (0..threads.len, threads.items) |i, thread| {
            @printf("Done\n");
            @join(thread.*);
            @free(args.items[i]);
        }

        @fdelete(filename);
        return img.export_bmp(filename);
    }


    /////////////
    // Helpers //
    /////////////
    fn draw_pixel(self: *const Camera, img: *const Image, world: *const Hittable, i: i64, j: i64, rng: *Rng) void {
        var pixel_color = Vec3::new(0.0, 0.0, 0.0);
        for (0..self.samples_per_pixel) |_| {
            const r = self.get_ray(i, j, rng);
            const c = self.ray_color(&r, self.max_depth, world, rng);
            pixel_color.x += c.x;
            pixel_color.y += c.y;
            pixel_color.z += c.z;
        }

        const color = Color::new(
            @floor(256.0 * ::PIXEL_INTENSITY.clamp(pixel_color.x * self.pixel_samples_scale)) as void as f64 as i64,
            @floor(256.0 * ::PIXEL_INTENSITY.clamp(pixel_color.y * self.pixel_samples_scale)) as void as f64 as i64,
            @floor(256.0 * ::PIXEL_INTENSITY.clamp(pixel_color.z * self.pixel_samples_scale)) as void as f64 as i64,
            255
        );
        img.set_pixel(color, i, j);
    }

    fn ray_color(self: *const Camera, r: *const Ray, depth: i64, world: *const Hittable, rng: *Rng) Vec3 {
        if (depth <= 0)
            return Vec3::new(0.0, 0.0, 0.0);

        var rec: HitRecord = undefined;
        if (world.hit(r, Interval::new(0.0, ::INFINITY), &rec)) {
            const dir = Vec3::random_on_hemisphere(rng, &rec.normal);
            const new_r = Ray::new(rec.p, dir);
            return self.ray_color(&new_r, depth-1, world, rng).muls(0.5);
        }

        const unit_direction = r.dir.unit_vector();
        const a = 0.5*(unit_direction.y + 1.0);
        const a_1 = 1.0 - a;
        return Vec3::new(a_1 + a*0.5, a_1 + a*0.7, a_1 + a);
    }

    fn get_ray(self: *const Camera, i: i64, j: i64, rng: *Rng) Ray {
        const offset = self.sample_square(rng);
        const pixel_sample = self.pixel00_loc
            .add(&self.pixel_delta_u.muls(i + offset.x))
            .add(&self.pixel_delta_v.muls(j + offset.y));
        return Ray::new(self.center, pixel_sample.sub(&self.center));
    }

    fn sample_square(self: *const Camera, rng: *Rng) Vec3 {
        return Vec3::new(rng.gen_f64() - 0.5, rng.gen_f64() - 0.5, 0);
    }

    fn render_worker(thread_args: *void) i64 {
        const args = thread_args as *RenderThreadArgs;
        const camera = args.camera;
        const img = args.img;
        const world = args.world;
        var rng = Rng::new(@nanoTimestamp(), @nanoTimestamp());
        for (args.min..args.max) |j| {
            for (0..camera.image_width) |i| {
                camera.draw_pixel(img, world, i, j, &rng);
            }
        }

        return 0;
    }
}

struct RenderThreadArgs {
    camera: *const Camera;
    world: *const Hittable;
    img: *const Image;
    min: i64;
    max: i64;
}