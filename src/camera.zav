use ::std::image::Image;
use ::std::image::Color;
use ::std::math;
use ::std::result::Result;
use ::std::io::IOError;
use ::std::collections::list::List;
use ::std::rand::Rng;

use ::vec3::Vec3;
use ::ray::Ray;
use ::hittable::Hittable;
use ::hittable::HitRecord;
use ::interval::Interval;

pub struct Camera {
    image_width: i64;
    image_height: i64;
    center: Vec3;
    pixel00_loc: Vec3;
    pixel_delta_u: Vec3;
    pixel_delta_v: Vec3;
    samples_per_pixel: i64;
    pixel_samples_scale: f64;
    max_depth: i64;
    defocus_angle: f64;
    defocus_disk_u: Vec3;
    defocus_disk_v: Vec3;

    pub fn new(
        image_width: i64,
        aspect_ratio: f64,
        samples_per_pixel: i64,
        max_depth: i64,
        v_fov: f64,
        look_from: Vec3,
        look_at: Vec3,
        v_up: Vec3,
        defocus_angle: f64,
        focus_dist: f64
    ) Camera {
        var self: Camera = undefined;
        self.image_width = image_width;
        self.image_height = math::max_i64(1, (image_width / aspect_ratio) as i64);
        self.pixel_samples_scale = 1.0 / samples_per_pixel;
        self.center = look_from;

        const theta = ::degrees_to_radians(v_fov);
        const h = @tan(theta / 2.0);
        const viewport_height = 2.0 * h * focus_dist;
        const viewport_width = viewport_height * (image_width as f64 / self.image_height as f64);

        // Calculate the u,v,w unit basis vectors for the camera coordinate frame
        const w = look_from.sub(&look_at).unit_vector();
        const u = v_up.cross(&w).unit_vector();
        const v = w.cross(&u);

        // Calculate the vectors across the horizontal and down the vertical viewport edges
        const viewport_u = u.muls(viewport_width);
        const viewport_v = v.neg().muls(viewport_height);

        // Calculate the horizontal and vertical delta vectors from pixel to pixel
        self.pixel_delta_u = viewport_u.divs(image_width);
        self.pixel_delta_v = viewport_v.divs(self.image_height);

        // Calculate the position of the upper left pixel
        const viewport_upper_left = self.center
            .sub(&w.muls(focus_dist))
            .sub(&viewport_u.divs(2.0))
            .sub(&viewport_v.divs(2.0));
        self.pixel00_loc = viewport_upper_left
            .add(&self.pixel_delta_u.add(&self.pixel_delta_v).muls(0.5));
        const defocus_radius = focus_dist * @tan(::degrees_to_radians(defocus_angle / 2.0));
        self.defocus_disk_u = u.muls(defocus_radius);
        self.defocus_disk_v = v.muls(defocus_radius);

        self.defocus_angle = defocus_angle;
        self.samples_per_pixel = samples_per_pixel;
        self.max_depth = max_depth;

        return self;
    }

    pub fn render(
        self: *const Camera,
        world: *const Hittable,
        filename: *const u8,
        thread_count: i64
    ) Result<i64, IOError> {
        const img = Image::new(self.image_width as u32, self.image_height as u32);
        defer img.free();

        var threads = List::<i64>::new();
        defer threads.free();
        var args = List::<*void>::new();
        defer args.free();

        const interval = thread_count < 2 ? 0 : self.image_height / thread_count;
        var thread_start = 0;
        for (1..thread_count) |i| {
            var temp: RenderThreadArgs = undefined;
            temp.camera = self;
            temp.world = world;
            temp.img = &img;
            temp.min = thread_start;
            temp.max = thread_start + interval;
            thread_start = temp.max;
            const arg = @malloc(@sizeof(temp)) as *RenderThreadArgs;
            arg.* = temp;
          
            const handle = @createThread(Camera::render_worker, arg as *void);
            threads.push(handle);
            args.push(arg as *void);
        }
    
        var rng = Rng::new(@nanoTimestamp(), @nanoTimestamp());
        for (thread_start..self.image_height) |j| {
            @printf("\rScanlines remaining: %d ", self.image_height - j);
            for (0..self.image_width) |i| {
                self.draw_pixel(&img, world, i, j, &rng);
            }
        }
        @printf("\rDone                  \n");

        for (0..threads.len, threads.items) |i, thread| {
            @printf("Done\n");
            @waitOne(thread.*);
            @free(args.items[i]);
        }

        @fdelete(filename);
        return img.export_bmp(filename);
    }


    /////////////
    // Helpers //
    /////////////
    fn draw_pixel(self: *const Camera, img: *const Image, world: *const Hittable, i: i64, j: i64, rng: *Rng) void {
        var pixel_color = Vec3::new(0.0, 0.0, 0.0);
        for (0..self.samples_per_pixel) |_| {
            const r = self.get_ray(i, j, rng);
            const c = self.ray_color(&r, self.max_depth, world, rng);
            pixel_color.x += c.x;
            pixel_color.y += c.y;
            pixel_color.z += c.z;
        }
        const r = pixel_color.x > 0.0 ? @sqrtf64(pixel_color.x * self.pixel_samples_scale) : 0.0;
        const g = pixel_color.y > 0.0 ? @sqrtf64(pixel_color.y * self.pixel_samples_scale) : 0.0;
        const b = pixel_color.z > 0.0 ? @sqrtf64(pixel_color.z * self.pixel_samples_scale) : 0.0;

        const color = Color::new(
            @floor(256.0 * ::PIXEL_INTENSITY.clamp(r)) as void as f64 as i64,
            @floor(256.0 * ::PIXEL_INTENSITY.clamp(g)) as void as f64 as i64,
            @floor(256.0 * ::PIXEL_INTENSITY.clamp(b)) as void as f64 as i64,
            255
        );
        img.set_pixel(color, i, j);
    }

    fn ray_color(self: *const Camera, r: *const Ray, depth: i64, world: *const Hittable, rng: *Rng) Vec3 {
        if (depth <= 0)
            return Vec3::new(0.0, 0.0, 0.0);

        var rec: HitRecord = undefined;
        if (world.hit(r, Interval::new(0.001, ::INFINITY), &rec)) {
            var scattered: Ray = undefined;
            var attenuation: Vec3 = undefined;
            if (rec.mat.scatter(r, &rec, &attenuation, &scattered, rng)) {
                return attenuation.mul(&self.ray_color(&scattered, depth-1, world, rng));
            }
            return Vec3::new(0.0, 0.0, 0.0);
        }

        const unit_direction = r.dir.unit_vector();
        const a = 0.5*(unit_direction.y + 1.0);
        const a_1 = 1.0 - a;
        return Vec3::new(a_1 + a*0.5, a_1 + a*0.7, a_1 + a);
    }

    fn get_ray(self: *const Camera, i: i64, j: i64, rng: *Rng) Ray {
        const offset = self.sample_square(rng);
        const pixel_sample = self.pixel00_loc
            .add(&self.pixel_delta_u.muls(i + offset.x))
            .add(&self.pixel_delta_v.muls(j + offset.y));

        const ray_origin = (self.defocus_angle <= 0.0) ? self.center : self.defocus_disk_sample(rng);
        return Ray::new(ray_origin, pixel_sample.sub(&ray_origin));
    }

    fn sample_square(self: *const Camera, rng: *Rng) Vec3 {
        return Vec3::new(rng.gen_f64() - 0.5, rng.gen_f64() - 0.5, 0);
    }

    fn defocus_disk_sample(self: *const Camera, rng: *Rng) Vec3 {
        const p = Vec3::random_in_unit_disk(rng);
        const offset = self.defocus_disk_u.muls(p.x)
            .add(&self.defocus_disk_v.muls(p.y));
        return self.center.add(&offset);
            //.add(&self.defocus_disk_u.muls(p.x * 0.0)) Function chaining broken for some reason
            //.add(&self.defocus_disk_v.muls(p.y * 0.0));
    }

    fn render_worker(thread_args: *void) i64 {
        const args = thread_args as *RenderThreadArgs;
        const camera = args.camera;
        const img = args.img;
        const world = args.world;
        var rng = Rng::new(@nanoTimestamp(), @nanoTimestamp());
        for (args.min..args.max) |j| {
            for (0..camera.image_width) |i| {
                camera.draw_pixel(img, world, i, j, &rng);
            }
        }

        return 0;
    }
}

struct RenderThreadArgs {
    camera: *const Camera;
    world: *const Hittable;
    img: *const Image;
    min: i64;
    max: i64;
}